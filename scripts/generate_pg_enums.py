#!/usr/bin/env python3

"""
PostgreSQL ENUM to Python Enum Generator

This script connects to a PostgreSQL database, inspects its system catalogs
to find all user-defined ENUM types, and generates a Python file containing
corresponding 'enum.Enum' classes.

This is useful as a supplement to tools like 'sqlacodegen' which do not
typically generate ENUM definitions.

Requirements:
    - psycopg2: 'pip install psycopg2-binary' (or 'psycopg2')

Example Usage:
    python generate_pg_enums.py "postgresql://myuser:mypassword@localhost:5432/mydatabase" > app/db_enums.py
"""

import sys
import re
from collections import defaultdict
try:
    import psycopg2
    from psycopg2 import sql
except ImportError:
    print(
        "Error: 'psycopg2' library not found. Please install it: pip install psycopg2-binary",
        file=sys.stderr
    )
    sys.exit(1)

# The SQL query to extract ENUM definitions.
# We join pg_type (types) with pg_enum (enum values)
# and filter out system schemas.
ENUM_QUERY = """
SELECT
    n.nspname AS "schema",
    t.typname AS "enum_name",
    e.enumlabel AS "enum_label"
FROM
    pg_type t
JOIN
    pg_enum e ON t.oid = e.enumtypid
JOIN
    pg_namespace n ON t.typnamespace = n.oid
WHERE
    n.nspname NOT IN ('pg_catalog', 'information_schema')
    AND t.typtype = 'e'
ORDER BY
    n.nspname, t.typname, e.enumsortorder;
"""

def to_camel_case(snake_str: str) -> str:
    """Converts a snake_case string to CamelCase."""
    return "".join(x.capitalize() for x in snake_str.split('_'))

def sanitize_member_name(label: str) -> str:
    """
    Converts an enum label (which can be any string) into a
    valid, conventional Python identifier (UPPER_CASE).
    """
    # Replace invalid chars with underscore
    sanitized = re.sub(r'[^a-zA-Z0-9_]', '_', label)
    
    # Ensure it doesn't start with a number
    if re.match(r'^[0-9]', sanitized):
        sanitized = '_' + sanitized
        
    # Convert to upper-case
    sanitized = sanitized.upper()

    # Handle case where label was empty or just invalid chars
    if not sanitized:
        return '_EMPTY'
        
    return sanitized

def main():
    """Main execution function."""
    
    if len(sys.argv) < 2:
        print(
            "Error: Missing database URL.\n"
            "Usage: python generate_pg_enums.py \"postgresql://user:pass@host:port/dbname\" > enums.py",
            file=sys.stderr
        )
        sys.exit(1)
    
    db_url = sys.argv[1]
    
    # Check for any other arguments, like a schema, which is no longer supported
    # in this simple version.
    if len(sys.argv) > 2:
        print(
            "Warning: Additional arguments are ignored. Only the first argument (db_url) is used.",
            file=sys.stderr
        )

    conn = None
    try:
        # --- 1. Connect to the database ---
        conn = psycopg2.connect(dsn=db_url)
        cur = conn.cursor()

        # --- 2. Execute the introspection query ---
        cur.execute(ENUM_QUERY)
            
        rows = cur.fetchall()

    except Exception as e:
        print(f"Error connecting to or querying database: {e}", file=sys.stderr)
        sys.exit(1)
    finally:
        if conn:
            conn.close()

    if not rows:
        print(f"No user-defined enums found in database at '{db_url}'.", file=sys.stderr)
        # We can still create the file, just with the import
        rows = []

    # --- 3. Process the query results ---
    # Group labels by enum: (schema, enum_name) -> [label1, label2, ...]
    enums_data = defaultdict(list)
    for schema, enum_name, label in rows:
        enums_data[(schema, enum_name)].append(label)

    # --- 4. Build the Python file content ---
    file_content = [
        "from enum import Enum\n",
        "from typing import list\n\n",
        "# This file is auto-generated by generate_pg_enums.py\n",
        "# Do not edit this file manually.\n\n",
    ]

    if not enums_data:
        file_content.append("# No user-defined ENUMs found in the database.\n")

    for (schema, enum_name), labels in enums_data.items():
        # Class name in CamelCase, e.g., 'user_status' -> 'UserStatus'
        class_name = to_camel_case(enum_name)
        
        # We add the schema name to the class name if it's not 'public'
        # to avoid name collisions. 'public.user_status' -> 'UserStatus'
        # 'billing.user_status' -> 'BillingUserStatus'
        if schema != 'public':
            class_name = f"{to_camel_case(schema)}{class_name}"

        file_content.append(f"class {class_name}(Enum):\n")
        
        used_member_names = set()
        for label in labels:
            # Member name, e.g., 'pending-approval' -> 'PENDING_APPROVAL'
            member_name = sanitize_member_name(label)
            
            # Handle collisions, e.g., 'a-b' and 'a_b' both sanitize to 'A_B'
            if member_name in used_member_names:
                i = 1
                new_member_name = f"{member_name}_{i}"
                while new_member_name in used_member_names:
                    i += 1
                    new_member_name = f"{member_name}_{i}"
                member_name = new_member_name
            
            used_member_names.add(member_name)
            
            # Write the member: PENDING_APPROVAL = "pending-approval"
            file_content.append(f"    {member_name} = {repr(label)}\n")
        
        # Add a useful classmethod to get all string values
        file_content.append("\n    @classmethod\n")
        file_content.append(f"    def get_values(cls) -> list[str]:\n")
        file_content.append(f"        \"\"\"Returns all string values of the enum.\"\"\"\n")
        file_content.append(f"        return [e.value for e in cls]\n")
        file_content.append("\n\n")

    # --- 5. Print the content to stdout ---
    try:
        # Join all content and print once to stdout
        print("".join(file_content))
        
        # Print a success message to stderr so it doesn't pollute the output file
        print(f"\nSuccessfully generated {len(enums_data)} enum(s).", file=sys.stderr)
        
    except Exception as e:
        print(f"Error writing to stdout: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()


