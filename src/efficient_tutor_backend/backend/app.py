'''
Main backend API response
'''
from flask import Blueprint, request, jsonify
from werkzeug.security import generate_password_hash, check_password_hash
import time

# Import the DatabaseHandler from its module
from ..core.tuition_generator import TuitionGenerator
from ..database.db_handler import DatabaseHandler

# Instead of a full Flask app, we create a Blueprint to keep routes organized.
main_routes = Blueprint('main_routes', __name__)

# Instantiate the database handler which will be used by our routes.
db = DatabaseHandler()


@main_routes.route('/', methods=['GET'])
def health_check():
    """
    Health check endpoint to confirm the server is running and can connect to the DB.
    """
    if not db.check_connection():
        return jsonify({"error": "Database connection failed"}), 503
    return jsonify({"status": "ok", "message": "Backend is running and database is connected"}), 200


@main_routes.route('/signup', methods=['POST'])
def signup():
    """
    Handles new user registration.
    """
    data = request.get_json()
    email = data.get('email')
    password = data.get('password')

    if not email or not password:
        return jsonify({"error": "Email and password are required"}), 400

    # Securely hash the password before storing it.
    hashed_password = generate_password_hash(password, method='pbkdf2:sha256:600000')
    
    user_data, message = db.signup_user(email, hashed_password)
    if not user_data:
        # 409 Conflict is the standard code for "already exists".
        return jsonify({"error": message}), 409
    
    print(f"New user signed up: {email} (ID: {user_data['id']})")
    return jsonify({"message": message, "user": user_data}), 201


@main_routes.route('/login', methods=['POST'])
def login():
    """
    Handles user login.
    """
    data = request.get_json()
    email = data.get('email')
    password = data.get('password')

    if not email or not password:
        return jsonify({"error": "Email and password are required"}), 400

    # The db_handler will fetch the user and the app will check the password.
    user_record = db.get_user_by_email(email)

    if user_record and check_password_hash(user_record['password'], password):
        print(f"User logged in: {email}")
        user_data_for_frontend = {
            "id": str(user_record['id']),
            "email": user_record['email'],
            "isFirstSignIn": user_record['is_first_sign_in']
        }
        return jsonify({"message": "Login successful", "user": user_data_for_frontend}), 200
    else:
        # 401 Unauthorized is the standard code for login failure.
        return jsonify({"error": "Invalid email or password"}), 401


@main_routes.route('/students', methods=['GET', 'POST', 'DELETE'])
def handle_students():
    """
    Handles all CRUD operations for students, scoped to the logged-in user.
    """
    if request.method == 'GET':
        user_id = request.args.get('userId')
    else: # POST or DELETE
        user_id = request.get_json().get('userId')

    if not user_id:
        return jsonify({"error": "Invalid or missing user ID"}), 401

    if request.method == 'GET':
        students = db.get_students(user_id)
        return jsonify(students), 200

    if request.method == 'POST':
        time.sleep(1.5) # Simulate processing delay for loading spinner
        student_data = request.get_json().get('student')
        student_id = db.save_student(user_id, student_data)

        # --- TRIGGER THE REGENERATION ---
        # After saving the student, regenerate the entire tuition list
        print("Student data saved. Triggering tuition list regeneration...")
        generator = TuitionGenerator(db)
        generator.regenerate_all_tuitions()
        # --- END OF TRIGGER ---

        print(f"Saved student '{student_data['firstName']}' for user {user_id}") # No longer nested in 'basicInfo'
        return jsonify({"message": "Student saved", "studentId": student_id}), 200

    if request.method == 'DELETE':
        student_id = request.get_json().get('studentId')
        if db.delete_student(user_id, student_id):
            print(f"Deleted student {student_id} for user {user_id}")
            return jsonify({"message": "Student deleted"}), 200
        return jsonify({"error": "Student not found"}), 404


# --- Mock Endpoints ---
# These endpoints return static data, as the real data is generated by the CSP worker.
# This backend's job is just to serve whatever is in the database.
# For now, we will keep them as mock.

@main_routes.route('/timetable', methods=['GET'])
def get_timetable():
    student_id = request.args.get('student_id')
    if not student_id: return jsonify({"error": "student_id parameter is required"}), 400
    # In a real scenario, this would be: `timetable = db.get_latest_timetable(student_id)`
    mock_timetable = { "tuitions": [ { "day": "saturday", "subject": "Math", "start": "10:00", "end": "11:30" }, { "day": "monday", "subject": "Physics", "start": "19:00", "end": "20:00" } ] }
    return jsonify(mock_timetable)


@main_routes.route('/logs', methods=['GET'])
def get_logs():
    student_id = request.args.get('student_id')
    if not student_id: return jsonify({"error": "student_id is required"}), 400
    # In a real scenario, this would be: `logs = db.get_student_logs(student_id)`
    mock_logs = { "summary": { "unpaid_count": 3, "paid_count": 2, "total_due": 150.00 }, "detailed_logs": [ { "subject": 'Math', "date": '2025-09-04', "time_start": '10:00', "time_end": '11:30', "duration": '1.5h', "status": 'Paid', "attendees": ["John Doe"] }, { "subject": 'Physics', "date": '2025-09-01', "time_start": '19:00', "time_end": '20:00', "duration": '1.0h', "status": 'Unpaid', "attendees": ["John Doe", "Jane Smith"] } ] }
    return jsonify(mock_logs)
